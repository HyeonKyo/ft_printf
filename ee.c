#include <stdio.h>

// int	main()
// {
// 	printf("[%020.10d]\n", 10);

// 	return (0);
// }

/*
1. 공용체로 가변인자 값 받음.
	union / double과 size_t를 가지고 있음.
	1.5. flag등 사전 처리.
		=> 오류 상황
			1. + ' ' 동시에 쓰일 때
			2. - 0 동시에 쓰일 때
			3. prec = .0(or .)일 때 => 소수점 이하 출력 x, 반올림.(이거 자동으로 처리되게 작성)
			4. prec = .0(or .) , f = 0.0일 때 => 0만 출력(+, -, 0flag모두 정상 작동)
			5. prec이 음수로 들어오면 무시함.(zero flag도 멀쩡함.) => ft_printf.c에서 해결됨.
2. 정수형으로 저장된 데이터를 비트형태로 변환 가능.
	1. 정수를 2로 0이 될 때 까지 나눔
	2. 나머지 값을 계속 배열에 저장(1 or 0)
	3. 역순으로 나열하면 그게 비트로 표현한 데이터임.
3. 부호, 지수, 가수부분을 구분함.
	부호 : 맨 앞의 숫자가 1인지 0인지
	지수부 : 11자리 인트형 배열에 각 값 저장(1 or 0)
	가수부 : 52자리 인트형 배열에 각 값 저장
4. precision등의 값을 참고하여 십진수로 변환(반올림 적용)
    반올림 방법
	1. 가수부의 소수점 이하의 값을 십진수로 표현 => 어떻게?
		=>지수부 숫자 만큼 가수부앞의 자리부터 잘라냄
		=> 남은 가수부의 숫자들이 소수를 구성하는 숫자가 됨.
		=> 앞에서부터 2^-1, 2^-2, ...., 2^-n값을 나타냄
		=> 그 값들에 맞게 더해주면 소수 값이 나옴. 그 소수값을 변수 f라고 함.
		=> 만약 6자리 출력해야 한다면 f = f * 10^6을 하고,(자동으로 뒤에 0 붙음 => precision고려 x?)
			n = (size_t)f + 0.5를 하면 소수부분의 값을 정수 형태로 저장 가능함.
			그 정수형태의 숫자를 출력하면 됨.(itoa?)
5. 십진수 출력
*/

/*
함수 1. 사전 처리 함수(가변인자 받음, flag 중복, 에러 처리, 2진 비트로 배열 출력)
	=> 함수 1-1 : 2진수로 계속 나눠서 10진수 정수를 int형 배열[64]에 0 or 1(2진수)로 저장.
함수 2. 실수 저장 값의 비트에 맞게 부호, 지수, 가수부를 나눔.
	=> 함수 2-1 : 부호, 정수, 소수 부분 나눠 저장.
		=> 부호는 맨 앞이 0인지 1인지 확인(1 = 음수)
		=> 정수 부분은 실수를 정수형으로 캐스팅하면 됨.(. .0인 경우는 0.5를 더하고 캐스팅)
		=> 소수부분
			=> 지수부 숫자만큼 가수부 앞에서부터 버림(함수 2-3 : 2진수를 다시 10진수로 변경)
			=> 남은 가수부의 앞에서 부터 n번째가 1이면 + (2^-(n + 1))을 의미함.(거듭제곱함수 필요.)
				따라서 그 값들을 다 실수형 변수에 더해줌.(반복문 idx를 n으로 활용, 길면 함수로 뺌.)
			=> 출력해야하는 소수점 아래의 길이만큼 10^n만큼 곱해주고, 0.5를 더하면서 정수로 캐스팅
			=> 출력할 만큼의 숫자를 정수로 저장. => 나중에 소수 출력 시 이 숫자를 그대로 출력
			-----------------------------------------------------------
			=> 소수 부분을 precision만큼 정수로 출력하는 방법은 오버플로우 문제가 발생함.
			=> 따라서 소수 부분을 한 글자씩 출력하는 방안으로 변경
			=> 더해진 소수값에 10곱하고, 정수부분만 출력 => 반복문(precision만큼, 마지막은 반올림 적용)
			------------------------------------------------------------
			=> 지수부가 음수인 경우를 고려하지 않음.
			=> 지수부 < 0 => 0.xxx인 경우
			=> 지수부의 값을 참고하여, 가수부 중 소수점 이하의 이진 값들만 저장한 dec[52]배열 생성
				=> 지수부가 음수로 온 것은 역으로 적용시켜줌.
			=> dec을 참고하여 소수값을 계산.
3. case에 맞는 출력
	부호, 정수, 소수 부분을 flag, width에 맞춰서 출력 (prec은 함수2의 소수부분에서 해결하도록.)
*/

/*
e_print
1. 정수부분과 소수 부분의 계산법이 다름.
	=> 정수 부분계산, 소수부분 계산 후 더한 뒤 지수만큼 뒤로 미뤄줌?
	=> f_print와 동일하게 정수부, 소수부의 숫자를 따로 구한 뒤
	=> 정수부가 10보다 작을 때까지 10으로 나눠주며 카운트를 세서 .의 위치를 구하면
	=> 그 위치가 e+0x의 x값이 되고
	=> 다시 숫자의 정수부를 itoa로 출력하는데 숫자 하나 출력 후 .을 출력하고 이후 출력해줌.
		=> 만약 precision < 0인 경우는 첫 번째 숫자 출력 전에 반올림 필요함.
		=> 위에서 구한 x값 활용.
	=> 나머지 소수부분은 10^precision만큼(기본 = 6)곱한 뒤
	=> itoa로 출력해줌.
	=> 그 뒤 e+xx기호 출력.
*/